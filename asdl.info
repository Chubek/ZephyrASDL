This is asdl.info, produced by makeinfo version 6.8 from asdl.texi.


File: asdl.info,  Node: Top,  Next: Guide for ASDL and asdl(1),  Up: (dir)

asdl(1)
*******

* Menu:

* Guide for ASDL and asdl(1)::


File: asdl.info,  Node: Guide for ASDL and asdl(1),  Prev: Top,  Up: Top

1 Guide for ASDL and asdl(1)
****************************

'asdl(1)' is an implementation of the ZephyrASDL language, specified in
1997 by Appel, Wang, Korn, and Serra in the paper 'Zephyr Abstract
Syntax Description Language'.  The following document is a guide on how
to write ASDL specs and use the 'asdl(1)' translator utility, which
translates ASDL specs to C code.

   _Note_: When referring to our implementation of ASDL, we'll use
'asdl(1)'.  We will use 'ASDL' when referring to the language as a
whole.

   * [Building asdl(1)]:: How to build the package with make(1) and
companion files * [Using asdl(1)]:: How to use the utility * [The ASDL
and asdl(1) Grammar]:: The grammar that 'asdl(1)' accepts, in EBNF
Format * [The Built-in Types]:: The types which have been added to
asdl(1) which may be used by default * [Details of ASDL Language]:: How
to Define ASTs in ASDL * [The Constructor Functions]:: Constructor
functions in generated files * [Optional and Sequential Fields]:: Fields
with more than one members, and optional fields * [Using Generated
Files]:: How to use the generated files * [Future of asdl(1)]:: ASDL is
an abandoned language, but asdl(1) is not!

* Menu:

* Building asdl(1)::
* Using asdl(1)::
* The ASDL and asdl(1) Grammar::
* The Built-in Types::
* Details of ASDL Language::
* The Constructor Functions::
* Optional and Sequential Fields::
* Using Generated Files::
* Future of asdl(1)::


File: asdl.info,  Node: Building asdl(1),  Next: Using asdl(1),  Up: Guide for ASDL and asdl(1)

1.1 Building asdl(1)
====================

To build asdl(1), just run 'make'.  To install it, run 'make install'.

   In order to build asdl(1), you will need:

   * An implementation of Yacc and Lex (preferably Bison and Flex); * A
C compiler (like GCC) * Perl

   After installation, you can browse the man page by typing 'man 1
asdl' into terminal.  You can page this document by 'info asdl'.
Examples and companions will be located in '/usr/local/share/doc/asdl'
(omit '/local' if installed from a package manager).

   asdl(1) also comes with a VimScript which you can use with any
implementation of Vim to have syntax highlighting.  This file is called
'asdl.vim'.  Please consult Vim's documentation to see what needs to be
done to add it to your editor.


File: asdl.info,  Node: Using asdl(1),  Next: The ASDL and asdl(1) Grammar,  Prev: Building asdl(1),  Up: Guide for ASDL and asdl(1)

1.2 Using asdl(1)
=================

The 'asdl(1)' translator utility has several options and one argument.
The syntax for invoking it is:

asdl [-o output_file] [-d def_suffix] [-f fn_suffix] [-k kind_suffix] [-a arg_suffix] [-p fn_prefix] INPUT_FILE

   To explain each option in detail:

   * 'output_file': (default: STDOUT) This option specifies the output
file for the translated C source.  If it is not given, STDOUT is used.

   * 'def_suffix': (default: "def") This option specifies the suffix for
typedefs.  Basically, as we'll see, every tree has a name, and this name
is translated into a nested data structure.  Each structure is referred
to by its typedef (which is a pointer alias).  For verbatim, for a
structure named 'stmt', we get:

typedef struct stmt *stmt_def;

   * 'fn_suffix': (default: "create") This is actually the 'prefix', in
a way, but since there's also an 'fn_prefix', we call it that.  This
marks the fragment of text which precedes the name of sub-tree in
constructor functions.  So if we have a sub-tree named 'Add' for the
'stmt' tree, we get:

stmt_def create_add(/* arguments */);

   (Keep in mind that constructor functions are also declared).

   * 'kind_suffix': (default "kind") This is the suffix for
enumerations.  The translator emits two types of enumerations, one for
stubs, one for each sub-tree in the tree.  So the 'Add' subtree will
have the kind:

ADD_kind

   * 'arg_suffix': (default "arg") Basically, the argument name suffix.
Nothing special about this one.

   * 'fn_prefix': (empty by default) You can use this to declare
'static' or 'static inline' functions.  Just pass what you want prefixed
before the function declaration.


File: asdl.info,  Node: The ASDL and asdl(1) Grammar,  Next: The Built-in Types,  Prev: Using asdl(1),  Up: Guide for ASDL and asdl(1)

1.3 The ASDL and asdl(1) Grammar
================================

'asdl(1)' defines a superset for Zephyr ASDL. This superset includes
extended pre-defined types and Yacc-like embeds.  The grammar that
'asdl(1)' accepts can be described in EBNF format as:

### Syntactic Grammar

definitions ::= prelude { definition | comment } "%%" c-code
definition ::= type_id '=' type

type ::= sum_type | product_type

product_type ::= fields

sum_type ::= constructor { '|' constructor } [ "attributes" fields ]

constructor ::= con_id [ fields ]

fields ::= '(' field { ',' field } ')'

field ::= ( type_id | predef-types ) [ '?' | '*' ] [ id ]

prelude ::= "%{" c-code "%}"


### Lexical Grammar
 
predef-types ::= "int" 
        | "uint"
        | "size" 
        | "usize"
        | "boolean" 
        | "string"
        | "identifier"

id ::= con_id | type_id

con_id ::= [A-Z][a-zA-Z0-9_]*
type_id ::= [a-z][a-z0-9_]*

c-code ::= ? valid-c-code ?

comment ::= "### " .* \n


File: asdl.info,  Node: The Built-in Types,  Next: Details of ASDL Language,  Prev: The ASDL and asdl(1) Grammar,  Up: Guide for ASDL and asdl(1)

1.4 The Built-in Types
======================

ASDL only supports 2 built-in types (int and identifier).  But asdl(1)
supports:

   * int, uint * size, usize, * boolean * identifier * string

   'size' is translated to 'ssize_t'.  'usize' to 'size_t'.  'int' and
'uint' are translated to 'intmax_t' and 'uintmax_t'.  'identifier' is
translated into 'char*'.  string to 'uint8_t*'.  And 'boolean' to
'bool'.


File: asdl.info,  Node: Details of ASDL Language,  Next: The Constructor Functions,  Prev: The Built-in Types,  Up: Guide for ASDL and asdl(1)

1.5 Details of ASDL Language
============================

Based on the grammar above, the AST for 'm4(1)' syntax would be:

m4 = Define(string name, m4 definition)
   | ArgumentRef(int num)
   | Token(string*)

   Here, 'Define', 'ArgumentRef', and 'Token' are each called
*Constructors*.  What's between open parenthesis and close parenthesis
are called *Fields*.  A Field has a *Type ID* and an OPTIONAL *Id*.  The
*Type ID* may be referred to recursively.  The entire thing is a *Rule*.

   'asdl(1)' will generate a data structure for the 'm4' rule.  This
structure would be:

typedef struct m4 *m4_def; // this will be actually emitted before any rule is defined
struct m4 {
   enum {
        DEFINE_kind,
        ARGUMENTREF_kind,
        TOKEN_kind,
   };
   union {
        struct Define {
          uint8_t *name;
          m4_def *definition;
        } define;
        struct ArgumentRef {
          int num;
        };
        struct Token {
           struct {
             uint8_t **string_0;
             ssize_t num_string_0;
          } token_seq;
        };
   } value;
   m4_def *next;
};


File: asdl.info,  Node: The Constructor Functions,  Next: Optional and Sequential Fields,  Prev: Details of ASDL Language,  Up: Guide for ASDL and asdl(1)

1.6 The Constructor Functions
=============================

With each constructor, a 'create_<constructor>' function is generated,
with its arguments being the fields.  These functions use the 'ALLOC'
macro to allocate space for the structure.  You can define your own
'ALLOC' in the prelude:

%{
#define ALLOC(size) calloc(1, size)
%}

m4 = ...

   Now, as said before, you can always append your own C code after
everything is done, Ã  la Yacc:

m4 = ...
%%

int main(void) {
  return 0;
}


File: asdl.info,  Node: Optional and Sequential Fields,  Next: Using Generated Files,  Prev: The Constructor Functions,  Up: Guide for ASDL and asdl(1)

1.7 Optional and Sequential Fields
==================================

One thing to note is, in ASDL, you can use '*' after a type id (for
verbatim, 'string*') to denote sequential fields and '?'  after one to
denote optional.  In such cases, 'asdl(1)' will emit a structure in
place of these fields:

   * For sequential fields, the structure adds a reference to the type
and emits 'ssize_t' variable to keep the count of it.  You can see this
in action in the verbatim above.

   * For the optional fields, the second option is a 'bool' field,
denoting if the item exists.  No additional ref markers are generated.


File: asdl.info,  Node: Using Generated Files,  Next: Future of asdl(1),  Prev: Optional and Sequential Fields,  Up: Guide for ASDL and asdl(1)

1.8 Using Generated Files
=========================

You are free to use the generated files as you wish.  One way is to
generate the file as a header file (.h) and include it on top of your
main file so C preprocessor can append it.

   Another way is to declare functions as extern, and compile the file
alongside your main file.


File: asdl.info,  Node: Future of asdl(1),  Prev: Using Generated Files,  Up: Guide for ASDL and asdl(1)

1.9 Future of asdl(1)
=====================

In the future versions, tree-walker functions will be added.  It was
hesitant to add them at the moment because people would like to walk the
trees with their own use in mind.

   Another feature which will be added in the future is generation of a
separate header file that declares the functions and types.



Tag Table:
Node: Top69
Node: Guide for ASDL and asdl(1)205
Node: Building asdl(1)1710
Node: Using asdl(1)2572
Node: The ASDL and asdl(1) Grammar4397
Node: The Built-in Types5506
Node: Details of ASDL Language6063
Node: The Constructor Functions7318
Node: Optional and Sequential Fields7970
Node: Using Generated Files8743
Node: Future of asdl(1)9223

End Tag Table


Local Variables:
coding: utf-8
End:
